<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>FORΞSIGHT PΛNΞL</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        background: #050505;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        color: #0f6;
        font-family: "Share Tech Mono", monospace;
        overflow: hidden;
        /* 2. ダブルタップズームやスクロールを無効化 */
        touch-action: none;
        -webkit-user-select: none; /* テキスト選択も禁止 */
        user-select: none;
      }
      #game-container {
        position: relative;
        width: 100%;
        max-width: 400px;
        padding: 10px;
        box-sizing: border-box;
      }
      #menu {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        background: rgba(0, 0, 0, 0.95);
        padding: 30px;
        border: 2px solid #0f6;
        box-shadow: 0 0 30px #0f65;
        z-index: 10;
        width: 80%;
      }
      .mode-btn {
        display: block;
        width: 100%;
        padding: 15px;
        margin: 10px 0;
        background: #000;
        border: 1px solid #0f6;
        color: #0f6;
        cursor: pointer;
        font-family: inherit;
        font-size: 16px;
        -webkit-tap-highlight-color: transparent;
      }
      .mode-btn:hover {
        background: #0f6;
        color: #000;
      }
      #hud {
        position: absolute;
        top: -40px;
        width: calc(100% - 20px);
        display: flex;
        justify-content: space-between;
        font-size: 20px;
        text-shadow: 0 0 10px #0f6;
      }
      canvas {
        background: #000;
        border: 2px solid #333;
        width: 100%; /* 横幅いっぱいにフィット */
        height: auto;
        display: block;
        -webkit-tap-highlight-color: transparent; /* タップ時の青い枠を消す */
      }
      .time-container {
        position: absolute;
        bottom: -25px;
        width: calc(100% - 20px);
        height: 8px;
        background: #111;
        border: 1px solid #333;
        border-radius: 4px;
        overflow: hidden;
      }
      #time-bar {
        width: 100%;
        height: 100%;
        background: #0f6;
        box-shadow: 0 0 15px #0f6;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div id="hud">
        <span id="floor">FLOOR: 0</span>
        <span
          id="mode-label"
          style="font-size: 12px; align-self: center; color: #0a6"
          >READY</span
        >
      </div>

      <div id="menu">
        <h1 style="letter-spacing: 5px; margin-bottom: 5px; font-size: 28px">
          FORΞSIGHT
        </h1>
        <div
          style="font-size: 9px; color: #0f6; margin-bottom: 20px; opacity: 0.7"
        >
          NEURAL TRAINING INTERFACE
        </div>
        <button class="mode-btn" onclick="startGame('practice')">
          PRACTICE (0-2)
        </button>
        <button class="mode-btn" onclick="startGame('main')">
          MAIN TOWER (0-5)
        </button>
        <button class="mode-btn" onclick="startGame('chain2')">2-CHAIN</button>
        <button class="mode-btn" onclick="startGame('chain3')">3-CHAIN</button>
      </div>

      <canvas id="main" width="400" height="500"></canvas>
      <div class="time-container"><div id="time-bar"></div></div>
    </div>

    <script>
      // --- [以前のロジックをそのまま継承。マウスイベントをタッチにも対応させるために念のため修正] ---

      const pColors = {
        target: "#ff0033",
        1: "#FF8C00",
        2: "#FFD700",
        3: "#00FF7F",
        4: "#00BFFF",
        5: "#9932CC",
      };

      class Pillar {
        constructor(x, y, depth) {
          this.x = x;
          this.y = y;
          this.depth = depth;
          this.panels = new Array(depth).fill("normal");
          this.shake = 0;
          this.flash = 0;
        }
        pull() {
          this.panels.shift();
          this.panels.push("normal");
        }
        setPanel(foresight) {
          this.panels.shift();
          if (foresight === 0) this.panels.push("target");
          else {
            this.panels.push(`fake-${foresight}`);
            this.panels[this.depth - foresight - 1] = `foresight-${foresight}`;
          }
        }
      }

      const canvas = document.getElementById("main");
      const ctx = canvas.getContext("2d");
      let pillars = [],
        floor = 0,
        currentMode = "";
      let timeLeft = 100,
        timerId = null;
      const depth = 10,
        pSize = 100,
        pSpace = 15;
      const offsetX = (canvas.width - (3 * pSize + 2 * pSpace)) / 2;
      const offsetY = (canvas.height - (3 * pSize + 2 * pSpace)) / 2;

      let lastTargetIdx = -1;

      function startGame(mode) {
        currentMode = mode;
        floor = -depth;
        timeLeft = 100;
        pillars = [];
        lastTargetIdx = -1;
        for (let i = 0; i < 9; i++)
          pillars.push(new Pillar(i % 3, Math.floor(i / 3), depth));
        for (let i = 0; i < depth; i++) setupInitialFloor(i);
        document.getElementById("menu").style.display = "none";
        document.getElementById("mode-label").innerText = mode.toUpperCase();
        updateHUD();
        startTimer();
      }

      function setupInitialFloor(i) {
        let f = 0;
        if (currentMode === "practice") f = i < 4 ? 0 : i < 7 ? 1 : 2;
        else if (currentMode === "main") f = i < 3 ? 0 : 1;
        else if (currentMode === "chain2") f = i < 2 ? i : 2;
        else if (currentMode === "chain3") f = i < 3 ? i : 3;
        injectTarget(f);
      }

      function injectTarget(foresight) {
        // 候補の抽出条件に「前回の位置（lastTargetIdx）ではないこと」を追加
        let candidates = pillars
          .map((_, i) => i)
          .filter(
            (i) =>
              i !== lastTargetIdx && // 【追加】前回の柱を除外
              pillars[i].panels[depth - foresight] === "normal" &&
              pillars[i].panels[depth - 1] === "normal"
          );

        // もし候補が空になった場合のセーフティ
        if (candidates.length === 0) {
          candidates = pillars
            .map((_, i) => i)
            .filter((i) => i !== lastTargetIdx);
        }

        const targetIdx =
          candidates[Math.floor(Math.random() * candidates.length)];

        // 今回選んだインデックスを保存
        lastTargetIdx = targetIdx;

        pillars.forEach((p, i) => {
          if (i === targetIdx) p.setPanel(foresight);
          else p.pull();
        });
        floor++;
        timeLeft = Math.min(100, timeLeft + 10);
      }

      function startTimer() {
        if (timerId) clearInterval(timerId);
        timerId = setInterval(() => {
          let speed = 0.4 + Math.max(0, floor) / 150;
          timeLeft -= speed;
          document.getElementById("time-bar").style.width =
            Math.max(0, timeLeft) + "%";
          document.getElementById("time-bar").style.background =
            timeLeft < 30 ? "#f44" : "#0f6";
          if (timeLeft <= 0) gameOver("TIME EXHAUSTED");
        }, 50);
      }

      function gameOver(reason) {
        clearInterval(timerId);
        alert(`${reason}\nFINAL FLOOR: ${Math.max(0, floor)}`);
        document.getElementById("menu").style.display = "block";
      }

      function updateHUD() {
        document.getElementById("floor").innerText = `FLOOR: ${Math.max(
          0,
          floor
        )}`;
      }

      function getNextForesight() {
        const f = Math.max(0, floor);
        if (currentMode === "practice") return Math.floor(Math.random() * 3);
        if (currentMode === "chain2") return 2;
        if (currentMode === "chain3") return 3;
        let possible = [0, 1, 2];
        if (f > 15) possible.push(3);
        if (f > 35) possible.push(4);
        if (f > 60) possible.push(5);
        const weights = [10, 10, 10, 5, 3, 2];
        let pool = [];
        possible.forEach((val) => {
          for (let i = 0; i < weights[val]; i++) pool.push(val);
        });
        return pool[Math.floor(Math.random() * pool.length)];
      }

      // iPhoneでのタップ操作感を向上させるための統合イベント
      function handlePointer(e) {
        if (document.getElementById("menu").style.display !== "none") return;

        // タッチでもマウスでも座標を正しく取得
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        // Canvas内のスケーリングを考慮した座標計算
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mx = (clientX - rect.left) * scaleX;
        const my = (clientY - rect.top) * scaleY;

        pillars.forEach((p) => {
          const px = offsetX + p.x * (pSize + pSpace),
            py = offsetY + p.y * (pSize + pSpace);
          if (mx > px && mx < px + pSize && my > py && my < py + pSize) {
            if (p.panels[0] === "target" || p.panels[0].startsWith("fake")) {
              p.flash = 1.0;
              injectTarget(getNextForesight());
              updateHUD();
            } else {
              p.shake = 20;
              timeLeft -= 12;
              if (timeLeft <= 0) gameOver("CRITICAL ERROR");
            }
          }
        });
        // デフォルトの挙動（スクロール等）を抑制
        if (e.cancelable) e.preventDefault();
      }

      canvas.addEventListener("touchstart", handlePointer, { passive: false });
      canvas.addEventListener("mousedown", handlePointer);

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        pillars.forEach((p) => {
          const px =
            offsetX +
            p.x * (pSize + pSpace) +
            (Math.random() * p.shake - p.shake / 2);
          const py = offsetY + p.y * (pSize + pSpace);
          if (p.shake > 0) p.shake *= 0.8;
          let color = "#112211",
            label = "",
            glow = false;
          const current = p.panels[0];
          if (current === "target") {
            color = pColors.target;
            glow = true;
          } else if (current.startsWith("foresight")) {
            label = current.split("-")[1];
            color = pColors[label] || "#fff";
            glow = true;
          }
          ctx.save();
          ctx.translate(px + pSize / 2, py + pSize / 2);
          if (glow) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.85;
          } else {
            ctx.fillStyle = color;
            ctx.globalAlpha = 1;
          }
          ctx.beginPath();
          const r = 4;
          ctx.moveTo(-pSize / 2 + r, -pSize / 2);
          ctx.arcTo(pSize / 2, -pSize / 2, pSize / 2, pSize / 2, r);
          ctx.arcTo(pSize / 2, pSize / 2, -pSize / 2, pSize / 2, r);
          ctx.arcTo(-pSize / 2, pSize / 2, -pSize / 2, -pSize / 2, r);
          ctx.arcTo(-pSize / 2, -pSize / 2, pSize / 2, -pSize / 2, r);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = glow ? "#fff" : "#353";
          ctx.lineWidth = 1;
          ctx.stroke();
          if (label) {
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = "#fff";
            ctx.font = "bold 56px 'Share Tech Mono', monospace";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(label, 0, 0);
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-20, -28);
            ctx.lineTo(20, -28);
            ctx.moveTo(-20, 28);
            ctx.lineTo(20, 28);
            ctx.stroke();
          }
          if (p.flash > 0) {
            ctx.fillStyle = "#fff";
            ctx.globalAlpha = p.flash;
            ctx.fill();
            p.flash *= 0.85;
          }
          ctx.restore();
        });
        requestAnimationFrame(draw);
      }
      draw();
    </script>
  </body>
</html>
